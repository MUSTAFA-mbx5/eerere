# -*- coding: utf-8 -*-
# ==================================================================================
# ===   BOT ME AL MUSTAFA - v20 (ARABIC KEYWORDS & COMMAND FLEXIBILITY FIX)      ===
# ==================================================================================
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø£ÙˆÙ„: Ø§Ù„Ø§Ø³ØªÙŠØ±Ø§Ø¯Ø§Øª ÙˆØ§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø£ÙˆÙ„ÙŠØ© ---

import os
import sys
import asyncio
import logging
import traceback
import time
import math
import uuid
from datetime import datetime, timedelta

# --- Ù…ÙƒØªØ¨Ø§Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ù„ÙØ§Øª ---
import fitz
import docx
import pptx
import nest_asyncio

# --- Ù…ÙƒØªØ¨Ø§Øª ØªÙ„ÙŠØ«ÙˆÙ† ---
from telethon import TelegramClient, events
from telethon.sessions import StringSession
from telethon.tl.types import User
from telethon.errors.rpcerrorlist import (
    PeerIdInvalidError, MessageDeleteForbiddenError, FileReferenceExpiredError,
    FloodWaitError, ChatWriteForbiddenError, UserIsBlockedError
)

# --- Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© ---
try:
    import win32print
    import pdf_to_printer
    WINDOWS_PRINTING_ENABLED = True
except ImportError as e:
    WINDOWS_PRINTING_ENABLED = False
    print("=" * 60)
    print("!!! âš ï¸ ØªØ­Ø°ÙŠØ±: Ø¥Ø­Ø¯Ù‰ Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ØºÙŠØ± Ù…Ø«Ø¨ØªØ©.")
    print(f"!!! Ø§Ù„Ø®Ø·Ø£: {e}")
    print("!!! Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©ØŒ Ù‚Ù… Ø¨ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØªØ§Ù„ÙŠØ© ÙÙŠ CMD:")
    print("pip install pywin32")
    print("pip install pdf-to-printer")
    print("=" * 60)

# --- ØªÙØ¹ÙŠÙ„ nest_asyncio ---
nest_asyncio.apply()

# --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ³Ø¬ÙŠÙ„ (Logging) ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot_activity.log', mode='a', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger('AlMustafaBot')

def log_problem(error_message):
    try:
        log_path = "D:\\bot_problems_log.txt"
        os.makedirs(os.path.dirname(log_path), exist_ok=True)
        with open(log_path, "a", encoding="utf-8") as f:
            f.write(f"--- Problem at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---\n")
            f.write(error_message)
            f.write("\n\n")
    except Exception as e:
        logger.error(f"CRITICAL: Could not write to D:\\bot_problems_log.txt. Error: {e}")

# --- Ù…ØªØºÙŠØ±Ø§Øª Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© ---
owner_id = None
bot_start_time = None
is_sleeping = False
custom_auto_reply_mode = False
custom_auto_reply_message = "ØµØ§Ø­Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù…ØªÙˆÙØ± Ø­Ø§Ù„ÙŠÙ‹Ø§. Ø³ÙŠØªÙ… Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙƒ Ù„Ø§Ø­Ù‚Ù‹Ø§."
SLEEP_APOLOGY_MESSAGE = "Ø¹Ø°Ø±Ù‹Ø§ØŒ ØµØ§Ø­Ø¨ Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù…ØªÙˆÙØ± Ø­Ø§Ù„ÙŠÙ‹Ø§. ØªÙ… Ø¥Ø¹Ù„Ø§Ù…Ù‡ Ø¨Ø±Ø³Ø§Ù„ØªÙƒ ÙˆØ³ÙŠØ±Ø¯ Ø¹Ù„ÙŠÙƒ ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª."
users_interacted_while_sleeping = {}
ignored_users = set()
user_pending_files = {}
pending_group_prints = {}
user_last_interaction_time = {}
user_wait_message = {}
stats_confirmed_orders = 0
stats_rejected_orders = 0
stats_total_confirmed_files = 0
stats_interacted_users = set()
global_daily_total_collected = 0

# --- Ø£Ø³Ø¹Ø§Ø± Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© ---
PRICE_PER_PAGE_LT50 = 50
PRICE_PER_PAGE_GTE50 = 40
COVER_BINDING_COST = 500

# --- Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙˆØ§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© ---
KEYWORDS_CONFIRM = ["Ù†Ø¹Ù…", "Ø§ÙŠ", "Ø£Ø¬Ù„", "Ù…ÙˆØ§ÙÙ‚", "Ù…ÙˆØ§ÙÙ‚Ø©", "ØªÙ…Ø§Ù…", "Ø§ÙˆÙƒÙŠ", "ÙˆÙƒ", "Ø§ÙˆÙƒ", "ØªÙ…", "ØªØ«Ø¨ÙŠØª"]
KEYWORDS_CANCEL = ["Ù„Ø§", "ÙƒÙ„Ø§", "Ø§Ø±ÙØ¶", "Ø§Ù„ØºØ§Ø¡"]
WELCOME_MESSAGE_TEXT = "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ {user_name} ÙÙŠ Ø¨ÙˆØª Ø§Ù„Ù…ØµØ·ÙÙ‰ Ù„Ù„Ø·Ø¨Ø§Ø¹Ø©!\n\nØ£Ø±Ø³Ù„ Ù„ÙŠ Ù…Ù„ÙØ§ØªÙƒ ÙˆØ³Ø£Ù‚ÙˆÙ… Ø¨Ø­Ø³Ø§Ø¨ ØªÙƒÙ„ÙØªÙ‡Ø§ Ù„Ùƒ. ğŸ–¨ï¸"
WELCOME_COOLDOWN = timedelta(hours=12)
ORDER_COMPLETION_MESSAGE_USER = (
    "ğŸ‰ Ø¹Ø²ÙŠØ²ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ø¨Ù†Ø¬Ø§Ø­.\n\n"
    "ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªÙ„Ø§Ù…Ù‡ Ø£Ùˆ Ø·Ù„Ø¨ Ø®Ø¯Ù…Ø© ØªÙˆØµÙŠÙ„.\n\n"
    "Ø´ÙƒØ±Ù‹Ø§ Ù„Ø§Ø®ØªÙŠØ§Ø±Ùƒ Ø®Ø¯Ù…Ø§ØªÙ†Ø§! ğŸ˜Š"
)

# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø«Ø§Ù„Ø«: Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ---
# ----------------------------------------------------------------------------------

def get_main_menu_text():
    return ("**ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø£ÙˆØ§Ù…Ø± Ø¨ÙˆØª Ø§Ù„Ù…ØµØ·ÙÙ‰:**\n\n"
            "`.Ù…1` - âš™ï¸ Ø£ÙˆØ§Ù…Ø± Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª\n`.Ù…2` - ğŸ’° Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø£Ø³Ø¹Ø§Ø±\n"
            "`.Ù…3` - ğŸ‘¥ Ø£ÙˆØ§Ù…Ø± Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†\n`.Ù…4` - ğŸ“Š Ø£ÙˆØ§Ù…Ø± Ù…ØªÙ‚Ø¯Ù…Ø©\n"
            "`.Ù…5` - ğŸ“¥ Ø£Ù…Ø± Ø­ÙØ¸ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· (`.Ø­Ù„Ùˆ`)\n\n"
            "Ø£Ø±Ø³Ù„ Ø§Ù„Ø£Ù…Ø± Ù…Ø¹ Ø§Ù„Ø±Ù‚Ù… Ù„Ù„ØªÙØ§ØµÙŠÙ„ (Ù…Ø«Ø§Ù„: `.Ù…1`)")

def get_status_commands_text():
    return ("**âš™ï¸ Ø£ÙˆØ§Ù…Ø± Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª:**\n"
            "`.Ù†Ø§ÙŠÙ…` - ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ….\n`.ÙƒØ§Ø¹Ø¯` - Ø¥Ù„ØºØ§Ø¡ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ… ÙˆØ§Ù„Ø±Ø¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ.\n"
            "`.ØªÙ†Ø§ÙŠÙ… <Ø±Ø³Ø§Ù„Ø©>` - ØªÙØ¹ÙŠÙ„ Ø±Ø¯ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ø®ØµØµ.\n"
            "`.ØªÙØ¹ÙŠÙ„` - Ø¹Ø±Ø¶ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª ÙˆÙ…Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„.\n`.ÙØ­Øµ` - ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„ ÙˆØ§Ù„Ù…ÙƒÙˆÙ†Ø§Øª.\n"
            "`.ØªÙŠØ³Øª` - ğŸ§ª ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ø§Ø¨Ø¹Ø§Øª ÙˆØ·Ø¨Ø§Ø¹Ø© ØµÙØ­Ø© Ø§Ø®ØªØ¨Ø§Ø±.\n"
            "`.Ù…` - â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.")

def get_prices_commands_text():
    return (f"**ğŸ’° Ø£ÙˆØ§Ù…Ø± ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±:**\n"
            f"`.Øª1 <Ù‚ÙŠÙ…Ø©>` - Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (< 50) `[{PRICE_PER_PAGE_LT50}]`\n"
            f"`.Øª2 <Ù‚ÙŠÙ…Ø©>` - Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (>= 50) `[{PRICE_PER_PAGE_GTE50}]`\n"
            f"`.Øª3 <Ù‚ÙŠÙ…Ø©>` - ØªÙƒÙ„ÙØ© Ø§Ù„Ø¬Ù„Ø§Ø¯ `[{COVER_BINDING_COST}]`\n"
            "`.Ù…` - â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.")

def get_users_commands_text():
    return ("**ğŸ‘¥ Ø£ÙˆØ§Ù…Ø± Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:**\n"
            "`.Ø³Ù…Ø§Ø­` (Ø¨Ø§Ù„Ø±Ø¯) - ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….\n`.Ø§Ù„ØºØ§Ø¡` (Ø¨Ø§Ù„Ø±Ø¯) - Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….\n"
            "`.Ø§Ù„ØºØ§Ø¡Ùƒ` - Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†.\n`.Ùƒ` (Ø¨Ø§Ù„Ø±Ø¯) - Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø·Ù„Ø¨.\n"
            "`.Ù…` - â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.")

def get_advanced_commands_text():
    return ("**ğŸ“Š Ø£ÙˆØ§Ù…Ø± Ù…ØªÙ‚Ø¯Ù…Ø©:**\n"
            "`.Ø§Ø°Ø§Ø¹Ø©` (Ø¨Ø§Ù„Ø±Ø¯) - Ø¨Ø« Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†.\n"
            "`.Ø³Ø¬Ù„` - Ø¹Ø±Ø¶ ØªÙ‚Ø±ÙŠØ± Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª ÙˆØ¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†Ù‡.\n"
            "`.Ù…` - â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.")

def get_save_command_text():
    return ("**ğŸ“¥ Ø£Ù…Ø± Ø­ÙØ¸ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· (`.Ø­Ù„Ùˆ`):**\n"
            "Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ù…Ø± `.Ø­Ù„Ùˆ` Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø£ÙŠ ÙˆØ³Ø§Ø¦Ø· Ù„Ø­ÙØ¸Ù‡Ø§ ÙÙŠ Ø±Ø³Ø§Ø¦Ù„Ùƒ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© ÙƒÙ…Ù„Ù.\n"
            "`.Ù…` - â†©ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.")

def calculate_price(pages_count):
    if pages_count == 0: return 0, 0
    price_per_page = PRICE_PER_PAGE_LT50 if pages_count < 50 else PRICE_PER_PAGE_GTE50
    base_p = pages_count * price_per_page
    return int(math.ceil(base_p / 250.0) * 250), int(math.ceil((base_p + COVER_BINDING_COST) / 250.0) * 250)

async def count_pages_for_document(file_path):
    def blocking_io_call(path):
        try:
            ext = os.path.splitext(path)[1].lower()
            if ext == '.pdf':
                with fitz.open(path) as doc: return len(doc)
            elif ext == '.docx':
                doc = docx.Document(path)
                return getattr(doc.core_properties, 'pages', len(doc.sections)) or len(doc.sections)
            elif ext == '.pptx':
                return len(pptx.Presentation(path).slides)
            return 0
        except Exception as e:
            logger.error(f"I/O Error counting pages for {path}: {e}")
            return 0
    return await asyncio.to_thread(blocking_io_call, file_path)

async def send_to_printer(file_to_print_path, printer_name):
    if not WINDOWS_PRINTING_ENABLED: return False, "Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ù…Ø¹Ø·Ù„Ø© Ù„Ø£Ù† Ù…ÙƒØªØ¨Ø© pywin32 ØºÙŠØ± Ù…Ø«Ø¨ØªØ©."
    
    try:
        import pdf_to_printer
    except ImportError:
        return False, "Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ù…Ø¹Ø·Ù„Ø© Ù„Ø£Ù† Ù…ÙƒØªØ¨Ø© pdf-to-printer ØºÙŠØ± Ù…Ø«Ø¨ØªØ©."

    def blocking_print_call(pdf_path, p_name):
        try:
            pdf_to_printer.print_file(filename=pdf_path, printer=p_name, win32_print=True)
            return True, f"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø£Ù…Ø± Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ø¨Ù†Ø¬Ø§Ø­ Ø¥Ù„Ù‰ '{p_name}'."
        except Exception as e:
            logger.error(f"Printing failed using pdf-to-printer: {e}", exc_info=True)
            log_problem(f"Printing failed for {pdf_path} on {p_name}\n{traceback.format_exc()}")
            return False, f"ÙØ´Ù„ Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©: {e}"
    return await asyncio.to_thread(blocking_print_call, file_to_print_path, printer_name)

async def find_or_download_file(status_msg, file_msg):
    file_name = next((a.file_name for a in file_msg.document.attributes if hasattr(a, 'file_name')), None)
    if not file_name: raise ValueError("Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù.")

    await status_msg.edit(f"ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† `{file_name}`...")
    potential_path = os.path.join(TELEGRAM_DESKTOP_PATH, file_name)
    if os.path.exists(potential_path):
        logger.info(f"File found in Telegram Desktop: {potential_path}")
        await status_msg.edit(f"âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù.")
        return potential_path

    await status_msg.edit(f"ğŸ“¥ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„ÙØŒ Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù…ÙŠÙ„...")
    download_path = os.path.join(BOT_DOWNLOAD_PATH, f"print_{file_msg.sender_id}_{uuid.uuid4()}_{file_name}")
    await file_msg.download_media(file=download_path)
    logger.info(f"File downloaded to: {download_path}")
    await status_msg.edit(f"âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù.")
    return download_path

async def send_group_notification(message, **kwargs):
    try: await client.send_message(PRINTING_GROUP_ID, message, **kwargs)
    except Exception as e: logger.error(f"Failed to send group notification: {e}")

def create_progress_bar(percentage):
    percentage = max(0, min(100, percentage))
    filled_length = int(percentage / 10)
    bar = 'â–ˆ' * filled_length + 'â–‘' * (10 - filled_length)
    return f"[{bar}] {percentage:.1f}%"

# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø±Ø§Ø¨Ø¹: Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø§Ù„Ùƒ ---
# ----------------------------------------------------------------------------------

# (ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§) ØªÙ… Ø¬Ø¹Ù„ Ù†Ù…Ø· Ø§Ù„Ø£Ù…Ø± Ø£ÙƒØ«Ø± Ù…Ø±ÙˆÙ†Ø©
@client.on(events.NewMessage(pattern=r'^\.Ù…(\d*)', outgoing=True))
async def command_menu(event):
    if event.sender_id != owner_id: return
    # ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø·Ø± Ø§Ù„ØªØ§Ù„ÙŠ Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ø¬Ø¯ÙŠØ¯
    match = event.pattern_match
    menu_num = match.group(1) if match else ""
    
    text = ""
    if not menu_num: text = get_main_menu_text()
    elif menu_num == "1": text = get_status_commands_text()
    elif menu_num == "2": text = get_prices_commands_text()
    elif menu_num == "3": text = get_users_commands_text()
    elif menu_num == "4": text = get_advanced_commands_text()
    elif menu_num == "5": text = get_save_command_text()
    else: text = "âš ï¸ Ø±Ù‚Ù… Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© ØºÙŠØ± ØµØ§Ù„Ø­. Ø£Ø±Ø³Ù„ `.Ù…` ÙÙ‚Ø·."
    
    await event.edit(text, parse_mode='md')

@client.on(events.NewMessage(pattern=r'^\.Ù†Ø§ÙŠÙ…$', outgoing=True))
async def go_sleep(event):
    if event.sender_id != owner_id: return
    global is_sleeping, custom_auto_reply_mode
    is_sleeping = True; custom_auto_reply_mode = False; logger.info("Bot state: Sleeping.")
    await event.edit("ğŸŒ™ ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ù†ÙˆÙ….")

@client.on(events.NewMessage(pattern=r'^\.ÙƒØ§Ø¹Ø¯$', outgoing=True))
async def wake_up(event):
    if event.sender_id != owner_id: return
    global is_sleeping, custom_auto_reply_mode, users_interacted_while_sleeping
    is_sleeping = False; custom_auto_reply_mode = False; logger.info("Bot state: Awake.")
    reply_msg = "â˜€ï¸ ØªÙ… ØªÙØ¹ÙŠÙ„ ÙˆØ¶Ø¹ Ø§Ù„Ø§Ø³ØªØ¹Ø¯Ø§Ø¯."
    if users_interacted_while_sleeping:
        reply_msg += "\n\nğŸ”” Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ø°ÙŠÙ† Ø±Ø§Ø³Ù„ÙˆÙƒ Ø£Ø«Ù†Ø§Ø¡ Ù†ÙˆÙ…Ùƒ:\n"
        for uid, data in users_interacted_while_sleeping.items():
            user_info = f"- {data['name']}"
            if data.get('username'): user_info += f" (@{data['username']})"
            reply_msg += user_info + "\n"
        users_interacted_while_sleeping.clear()
    await event.edit(reply_msg)

@client.on(events.NewMessage(pattern=r'^\.ØªÙ†Ø§ÙŠÙ…(?:\s+(.*))?$', outgoing=True))
async def set_auto_reply(event):
    if event.sender_id != owner_id: return
    global custom_auto_reply_mode, custom_auto_reply_message, is_sleeping
    message = event.pattern_match.group(1)
    if message and message.strip():
        custom_auto_reply_message = message.strip(); custom_auto_reply_mode = True; is_sleeping = False
        logger.info(f"Auto-reply enabled: '{custom_auto_reply_message}'")
        await event.edit(f"ğŸ¤– ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø±Ø¯ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ. Ø§Ù„Ø±Ø³Ø§Ù„Ø©:\n`{custom_auto_reply_message}`")
    else: await event.edit("âš ï¸ Ø®Ø·Ø£: ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø±Ø³Ø§Ù„Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±.")

@client.on(events.NewMessage(pattern=r'^\.ØªÙØ¹ÙŠÙ„$', outgoing=True))
async def bot_status(event):
    if event.sender_id != owner_id: return
    if not bot_start_time: return await event.edit("Ø§Ù„Ø¨ÙˆØª Ù„Ù… ÙŠØ¨Ø¯Ø£ Ø¨Ø´ÙƒÙ„ ÙƒØ§Ù…Ù„ Ø¨Ø¹Ø¯.")
    uptime = datetime.now() - bot_start_time
    d, r = divmod(uptime.total_seconds(), 86400); h, r = divmod(r, 3600); m, s = divmod(r, 60)
    uptime_str = f"{int(d)}ÙŠ {int(h)}Ø³ {int(m)}Ø¯"
    status = "ğŸŒ™ Ù†Ø§Ø¦Ù…" if is_sleeping else "ğŸ¤– Ø±Ø¯ ØªÙ„Ù‚Ø§Ø¦ÙŠ" if custom_auto_reply_mode else "â˜€ï¸ ÙƒØ§Ø¹Ø¯"
    await event.edit(f"**ğŸ“Š Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª:**\n- Ø§Ù„Ø­Ø§Ù„Ø©: **{status}**\n- Ù…Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„: **{uptime_str}**\n- Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ù…ØªØ¬Ø§Ù‡Ù„ÙˆÙ†: **{len(ignored_users)}**")

@client.on(events.NewMessage(pattern=r'^\.ÙØ­Øµ$', outgoing=True))
async def bot_check(event):
    if event.sender_id != owner_id: return
    report = "**ğŸ©º ÙØ­Øµ Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª:**\n"
    report += f"- Ø§ØªØµØ§Ù„ ØªÙ„ÙŠØ«ÙˆÙ†: `{'âœ… Ø³Ù„ÙŠÙ…' if client.is_connected() else 'âŒ Ù…Ù‚Ø·ÙˆØ¹'}`\n"
    report += f"- Ù…Ø³Ø§Ø± Ø§Ù„Ø¨Ø­Ø«: `{'âœ… Ù…ÙˆØ¬ÙˆØ¯' if os.path.exists(TELEGRAM_DESKTOP_PATH) else 'âŒ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'}`\n"
    report += f"- Ù…Ø³Ø§Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„: `{'âœ… Ù…ÙˆØ¬ÙˆØ¯' if os.path.exists(BOT_DOWNLOAD_PATH) else 'âŒ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'}`\n"
    
    if WINDOWS_PRINTING_ENABLED:
        printers_to_test = [p for p in [PRINTER_NAME_1, PRINTER_NAME_2] if p]
        if printers_to_test:
            report += "- Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ø§Ø¨Ø¹Ø§Øª:\n"
            for printer_name in printers_to_test:
                try:
                    h_printer = win32print.OpenPrinter(printer_name)
                    info = win32print.GetPrinter(h_printer, 2)
                    win32print.ClosePrinter(h_printer)
                    status_map = {0: "Ø¬Ø§Ù‡Ø²Ø©", 1: "Ù…ØªÙˆÙ‚ÙØ© Ù…Ø¤Ù‚ØªÙ‹Ø§", 4: "Ø¬Ø§Ø±Ù Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©"}
                    status_text = status_map.get(info['Status'], f"ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ ({info['Status']})")
                    report += f"  - `{printer_name}`: **{status_text}**\n"
                except Exception:
                    report += f"  - `{printer_name}`: **âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙˆØµÙˆÙ„**\n"
        else:
            report += "- Ø§Ù„Ø·Ø§Ø¨Ø¹Ø§Øª: `Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø£Ø³Ù…Ø§Ø¡ Ø·Ø§Ø¨Ø¹Ø§Øª`\n"
    else:
        report += "- Ø§Ù„Ø·Ø§Ø¨Ø¹Ø§Øª: `Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© ØºÙŠØ± Ù…Ø«Ø¨ØªØ©`\n"
        
    await event.edit(report, parse_mode='md')

@client.on(events.NewMessage(pattern=r'^\.Øª([1-3])\s+(\d+)$', outgoing=True))
async def adjust_price(event):
    if event.sender_id != owner_id: return
    ptype, pval = int(event.pattern_match.group(1)), int(event.pattern_match.group(2))
    global PRICE_PER_PAGE_LT50, PRICE_PER_PAGE_GTE50, COVER_BINDING_COST
    name = ""
    if ptype == 1: PRICE_PER_PAGE_LT50 = pval; name = "Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (< 50)"
    elif ptype == 2: PRICE_PER_PAGE_GTE50 = pval; name = "Ø³Ø¹Ø± Ø§Ù„ØµÙØ­Ø© (>= 50)"
    elif ptype == 3: COVER_BINDING_COST = pval; name = "ØªÙƒÙ„ÙØ© Ø§Ù„Ø¬Ù„Ø§Ø¯"
    if name: await event.edit(f"âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« **{name}** Ø¥Ù„Ù‰ `{pval}` Ø¯ÙŠÙ†Ø§Ø±.")

@client.on(events.NewMessage(pattern=r'^\.Ø³Ù…Ø§Ø­$', outgoing=True, func=lambda e: e.is_reply))
async def ignore_user(event):
    if event.sender_id != owner_id: return
    user_id = (await event.get_reply_message()).sender_id; ignored_users.add(user_id)
    await event.edit(f"ğŸš« ØªÙ… ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… `{user_id}`.")

@client.on(events.NewMessage(pattern=r'^\.Ø§Ù„ØºØ§Ø¡$', outgoing=True, func=lambda e: e.is_reply))
async def unignore_user(event):
    if event.sender_id != owner_id: return
    user_id = (await event.get_reply_message()).sender_id; ignored_users.discard(user_id)
    await event.edit(f"âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ `{user_id}`.")

@client.on(events.NewMessage(pattern=r'^\.Ø§Ù„ØºØ§Ø¡Ùƒ$', outgoing=True))
async def unignore_all(event):
    if event.sender_id != owner_id: return
    count = len(ignored_users); ignored_users.clear()
    await event.edit(f"âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ ØªØ¬Ø§Ù‡Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ({count}).")

@client.on(events.NewMessage(pattern=r'^\.Ùƒ$', outgoing=True, func=lambda e: e.is_reply))
async def send_completion_msg(event):
    if event.sender_id != owner_id: return
    try:
        await client.send_message((await event.get_reply_message()).sender_id, ORDER_COMPLETION_MESSAGE_USER)
        await event.delete()
    except Exception as e: await event.edit(f"âŒ ÙØ´Ù„: {e}")

@client.on(events.NewMessage(pattern=r'^\.Ø§Ø°Ø§Ø¹Ø©$', outgoing=True, func=lambda e: e.is_reply))
async def broadcast(event):
    if event.sender_id != owner_id: return
    reply_msg = await event.get_reply_message()
    all_users = list(user_last_interaction_time.keys())
    if not all_users: return await event.edit("â„¹ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ù…ØªÙØ§Ø¹Ù„ÙˆÙ† Ù„Ù„Ø¨Ø« Ø¥Ù„ÙŠÙ‡Ù….")
    await event.edit(f"â³ Ø¬Ø§Ø±Ù Ø¨Ø« Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ {len(all_users)} Ù…Ø³ØªØ®Ø¯Ù…...")
    success, fail = 0, 0
    for uid in all_users:
        try: await client.forward_messages(uid, reply_msg); success += 1; await asyncio.sleep(0.2)
        except Exception: fail += 1
    await event.edit(f"âœ… **Ø§ÙƒØªÙ…Ù„ Ø§Ù„Ø¨Ø«:**\n- Ù†Ø¬Ø­: {success}\n- ÙØ´Ù„: {fail}")

@client.on(events.NewMessage(pattern=r'^\.Ø³Ø¬Ù„$', outgoing=True))
async def report_stats(event):
    if event.sender_id != owner_id: return
    global stats_confirmed_orders, stats_rejected_orders, stats_total_confirmed_files, stats_interacted_users, global_daily_total_collected
    report = (f"**ğŸ“Š ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø³Ø¬Ù„ (Ù…Ù†Ø° Ø¢Ø®Ø± Ø·Ù„Ø¨)**\n\n"
              f"ğŸ‘¥ Ù…ØªÙØ§Ø¹Ù„ÙˆÙ†: **{len(stats_interacted_users)}**\n"
              f"ğŸ‘ Ø·Ù„Ø¨Ø§Øª Ù…ÙˆØ§ÙÙ‚ Ø¹Ù„ÙŠÙ‡Ø§: **{stats_confirmed_orders}**\n"
              f"ğŸ‘ Ø·Ù„Ø¨Ø§Øª Ù…Ø±ÙÙˆØ¶Ø©: **{stats_rejected_orders}**\n"
              f"ğŸ“‚ Ù…Ù„ÙØ§Øª Ù…Ø¤ÙƒØ¯Ø©: **{stats_total_confirmed_files}**\n"
              f"ğŸ’° Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ Ø§Ù„Ù…Ø­ØµÙ‘Ù„: **{global_daily_total_collected}** Ø¯.Ø¹\n\n"
              f"_(ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø³Ø¬Ù„ Ù„Ù‡Ø°Ù‡ Ø§Ù„ÙØªØ±Ø©)_")
    await event.edit(report, parse_mode='md')
    stats_confirmed_orders = 0
    stats_rejected_orders = 0
    stats_total_confirmed_files = 0
    global_daily_total_collected = 0
    stats_interacted_users.clear()

@client.on(events.NewMessage(pattern=r'^\.Ø­Ù„Ùˆ$', outgoing=True, func=lambda e: e.is_reply))
async def save_media(event):
    if event.sender_id != owner_id: return
    reply_msg = await event.get_reply_message()
    if not reply_msg or not reply_msg.media: return await event.edit("âš ï¸ ÙŠØ¬Ø¨ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ ÙˆØ³Ø§Ø¦Ø·.")
    status_msg = await event.edit("ğŸ“¥ Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸...")
    try:
        sender = await reply_msg.get_sender()
        sender_name = f"{sender.first_name or ''} {sender.last_name or ''}".strip()
        caption = f"ğŸ’¾ Ù…Ù†: {sender_name} (`{sender.id}`)\nÙ…Ù† Ù…Ø­Ø§Ø¯Ø«Ø©: `{reply_msg.chat_id}`"
        temp_dir = os.path.join(BOT_DOWNLOAD_PATH, "temp_saves")
        os.makedirs(temp_dir, exist_ok=True)
        path = await reply_msg.download_media(file=temp_dir)
        await client.send_file('me', path, caption=caption, force_document=True, parse_mode='md')
        os.remove(path)
        await status_msg.edit("âœ… ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø¬Ø§Ø­ ÙÙŠ Ø±Ø³Ø§Ø¦Ù„Ùƒ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©.")
    except Exception as e: await status_msg.edit(f"âŒ ÙØ´Ù„ Ø§Ù„Ø­ÙØ¸: {e}")

@client.on(events.NewMessage(pattern=r'^\.ØªÙŠØ³Øª$', outgoing=True))
async def test_printer(event):
    if event.sender_id != owner_id: return
    if not WINDOWS_PRINTING_ENABLED:
        return await event.edit("âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±. Ù…ÙƒØªØ¨Ø© `pywin32` ØºÙŠØ± Ù…Ø«Ø¨ØªØ©.")

    await event.edit("ğŸ§ª **Ø¨Ø¯Ø¡ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø·Ø§Ø¨Ø¹Ø§Øª...**")
    report = "**ğŸ“ ØªÙ‚Ø±ÙŠØ± Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ø§Ø¨Ø¹Ø§Øª:**\n\n"
    printers_to_test = [p for p in [PRINTER_NAME_1, PRINTER_NAME_2] if p]
    if not printers_to_test:
        return await event.edit("âŒ Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø£Ø³Ù…Ø§Ø¡ Ø·Ø§Ø¨Ø¹Ø§Øª ÙÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.")

    found_printer = False
    for printer_name in printers_to_test:
        try:
            h_printer = win32print.OpenPrinter(printer_name)
            info = win32print.GetPrinter(h_printer, 2)
            win32print.ClosePrinter(h_printer)
            status_map = {0: "Ø¬Ø§Ù‡Ø²Ø© (Idle)", 1: "Ù…ØªÙˆÙ‚ÙØ© Ù…Ø¤Ù‚ØªÙ‹Ø§", 4: "Ø¬Ø§Ø±Ù Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©"}
            status_text = status_map.get(info['Status'], f"ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ (ÙƒÙˆØ¯: {info['Status']})")
            report += f"**Ø·Ø§Ø¨Ø¹Ø©: `{printer_name}`**\n"
            report += f"- Ø§Ù„Ø­Ø§Ù„Ø©: **{status_text}**\n"
            report += f"- Ù…Ù‡Ø§Ù… ÙÙŠ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±: **{info['cJobs']}**\n\n"
            found_printer = True
        except Exception as e:
            report += f"**Ø·Ø§Ø¨Ø¹Ø©: `{printer_name}`**\n- Ø§Ù„Ø­Ø§Ù„Ø©: **âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„ÙŠÙ‡Ø§**\n- Ø§Ù„Ø³Ø¨Ø¨: `{e}`\n\n"

    status_msg = await event.edit(report)

    if found_printer:
        try:
            import pdf_to_printer
            test_printer_name = printers_to_test[0]
            await status_msg.reply(f"ğŸ–¨ï¸ Ø¬Ø§Ø±Ù Ø¥Ø±Ø³Ø§Ù„ ØµÙØ­Ø© Ø§Ø®ØªØ¨Ø§Ø± Ø¥Ù„Ù‰ `{test_printer_name}`...")
            pdf_to_printer.print_windows_test_page(printer_name=test_printer_name)
            await status_msg.reply(f"âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØµÙØ­Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø¨Ù†Ø¬Ø§Ø­.")
        except ImportError:
            await status_msg.reply("âŒ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø·Ø¨Ø§Ø¹Ø© ØµÙØ­Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±. Ù…ÙƒØªØ¨Ø© `pdf-to-printer` ØºÙŠØ± Ù…Ø«Ø¨ØªØ©.")
        except Exception as e:
            await status_msg.reply(f"âŒ ÙØ´Ù„Øª Ø·Ø¨Ø§Ø¹Ø© ØµÙØ­Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±: `{e}`")

@client.on(events.NewMessage(pattern=r'^\.Ø·Ø¨Ø§Ø¹Ø©$'))
async def universal_print_command(event):
    is_owner = event.sender_id == owner_id
    is_group = event.chat_id == PRINTING_GROUP_ID

    if not event.is_reply:
        if is_owner: await event.reply("ğŸ“ ÙŠØ¬Ø¨ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø±Ø³Ø§Ù„Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ù„Ù Ù„Ù„Ø·Ø¨Ø§Ø¹Ø©.")
        return

    reply_msg = await event.get_reply_message()
    if not reply_msg.document:
        if is_owner: await event.reply("ğŸš« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø°ÙŠ ØªÙ… Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙ‡ Ù„ÙŠØ³ Ù…Ø³ØªÙ†Ø¯Ù‹Ø§ ØµØ§Ù„Ø­Ù‹Ø§.")
        return

    # Ù…Ù†Ø·Ù‚ Ø§Ù„Ù…Ø´ØºÙ„ ÙÙŠ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø© (Ø¨Ù…Ø§ ÙÙŠÙ‡Ù… Ø§Ù„Ù…Ø§Ù„Ùƒ)
    if is_group:
        job_data = pending_group_prints.pop(reply_msg.id, None)
        if not job_data:
            return await event.reply("âŒ Ù„Ù… Ø£Ø¬Ø¯ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù‡Ø°Ø§ Ø§Ù„Ø·Ù„Ø¨. Ù‚Ø¯ ÙŠÙƒÙˆÙ† ØªÙ…Øª Ø·Ø¨Ø§Ø¹ØªÙ‡.")
        
        chosen_printer = None
        if is_owner:
            printers = [p for p in [PRINTER_NAME_1, PRINTER_NAME_2] if p]
            if len(printers) > 1:
                options = "".join([f"\n`{i}` - {printer}" for i, printer in enumerate(printers, 1)])
                try:
                    prompt_msg = await event.reply(f"**ğŸ–¨ï¸ Ø§Ø®ØªØ± Ø§Ù„Ø·Ø§Ø¨Ø¹Ø©:**{options}\n\nÙ„Ø¯ÙŠÙƒ 15 Ø«Ø§Ù†ÙŠØ© Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±.")
                    async with client.conversation(event.chat_id, timeout=15) as conv:
                        response = await conv.get_response(from_users=owner_id)
                        choice = int(response.text.strip())
                        if 1 <= choice <= len(printers):
                            chosen_printer = printers[choice - 1]
                            await prompt_msg.edit(f"âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø·Ø§Ø¨Ø¹Ø©: `{chosen_printer}`.")
                        else:
                            await prompt_msg.edit("âŒ Ø§Ø®ØªÙŠØ§Ø± Ø®Ø§Ø·Ø¦. Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø·Ø§Ø¨Ø¹Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©.")
                except (asyncio.TimeoutError, ValueError, IndexError):
                    await prompt_msg.edit("â³ Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª Ø£Ùˆ Ø§Ø®ØªÙŠØ§Ø± Ø®Ø§Ø·Ø¦. Ø³ÙŠØªÙ… Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø·Ø§Ø¨Ø¹Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©.")

        status_msg = await event.reply(f"âœ… ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø£Ù…Ø± Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©. Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ø¶ÙŠØ±...")
        asyncio.create_task(execute_print_job(status_msg, job_data['file_msg'], job_data['user_id'], chosen_printer))
        return

    # Ù…Ù†Ø·Ù‚ Ø§Ù„Ù…Ø§Ù„Ùƒ ÙÙŠ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ø®Ø§ØµØ©
    if is_owner and event.is_private:
        status_msg = await event.reply("ğŸ–¨ï¸ Ø£Ù…Ø± Ø·Ø¨Ø§Ø¹Ø© Ù…Ø¨Ø§Ø´Ø±. Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ø¶ÙŠØ±...")
        original_sender_id = reply_msg.sender_id
        asyncio.create_task(execute_print_job(status_msg, reply_msg, original_sender_id))
        return

# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø®Ø§Ù…Ø³: Ù…Ø¹Ø§Ù„Ø¬ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ---
# ----------------------------------------------------------------------------------
@client.on(events.NewMessage(incoming=True, func=lambda e: e.is_private and not e.out))
async def handle_user_message(event):
    user_id = event.sender_id
    text = event.raw_text.strip().lower()
    user_entity = await event.get_sender()

    if not user_entity or user_entity.bot or user_id in ignored_users: return
    
    user_name = user_entity.first_name or f"User {user_id}"
    stats_interacted_users.add(user_id)

    if event.media and hasattr(event.media, 'ttl_seconds') and event.media.ttl_seconds:
        try:
            temp_dir_ttl = os.path.join(BOT_DOWNLOAD_PATH, "temp_saves")
            os.makedirs(temp_dir_ttl, exist_ok=True)
            path = await event.download_media(file=temp_dir_ttl)
            await client.send_file('me', path, caption=f"ğŸ–¼ï¸ ØµÙˆØ±Ø© Ø°Ø§ØªÙŠØ© Ø§Ù„ØªØ¯Ù…ÙŠØ± Ù…Ù†: {user_name} (`{user_id}`)")
            os.remove(path)
        except Exception as e:
            logger.error(f"Failed to save self-destructing media: {e}")
            log_problem(f"Failed to save self-destructing media from {user_id}\n{traceback.format_exc()}")
        return

    if is_sleeping:
        if user_id not in users_interacted_while_sleeping:
            users_interacted_while_sleeping[user_id] = {'name': user_name, 'username': user_entity.username}
            await event.reply(SLEEP_APOLOGY_MESSAGE)
            await send_group_notification(f"ğŸ”” Ø±Ø³Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† [{user_name}](tg://user?id={user_id}) Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù†ÙˆÙ….", parse_mode='md')
        return

    if event.document:
        if user_id in user_wait_message:
            try: await user_wait_message.pop(user_id).delete()
            except Exception: pass
            
        status_msg = await event.reply("â³ Ø§Ø³ØªÙ„Ù…Øª Ø§Ù„Ù…Ù„ÙØŒ Ø¬Ø§Ø±Ù Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...")
        temp_path = None
        try:
            file_name = next((a.file_name for a in event.document.attributes if hasattr(a, 'file_name')), "file.tmp")
            temp_path = os.path.join(BOT_DOWNLOAD_PATH, f"temp_{user_id}_{uuid.uuid4()}_{file_name}")
            await event.download_media(file=temp_path)
            pages = await count_pages_for_document(temp_path)
            
            if pages > 0:
                base, cover = calculate_price(pages)
                if user_id not in user_pending_files: user_pending_files[user_id] = {}
                user_pending_files[user_id][event.id] = {'msg': event.message, 'price': base, 'pages': pages}
                price_msg = (f"ğŸ“„ **Ø§Ù„Ù…Ù„Ù:** `{file_name}`\n"
                             f"ğŸ“– **Ø§Ù„ØµÙØ­Ø§Øª:** {pages}\n"
                             f"ğŸ’° **Ø§Ù„ØªÙƒÙ„ÙØ©:** {base} Ø¯.Ø¹ (Ø¨Ø¯ÙˆÙ† ØªØ¬Ù„ÙŠØ¯) | {cover} Ø¯.Ø¹ (Ù…Ø¹ ØªØ¬Ù„ÙŠØ¯)\n\n"
                             f"âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù„Ù Ù„Ø·Ù„Ø¨Ùƒ. Ø£Ø±Ø³Ù„ `Ù†Ø¹Ù…` Ø£Ùˆ `ØªØ«Ø¨ÙŠØª` Ù„Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª Ù„Ù„Ù…ÙƒØªØ¨Ø©.")
                await status_msg.edit(price_msg)
            else: await status_msg.edit("âŒ Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø­Ø³Ø§Ø¨ Ø§Ù„ØµÙØ­Ø§Øª.")
            
            if os.path.exists(temp_path): os.remove(temp_path)
        except Exception as e:
            logger.error(f"File processing error: {e}", exc_info=True)
            log_problem(f"File processing error for user {user_id}\n{traceback.format_exc()}")
            await status_msg.edit(f"âŒ Ø®Ø·Ø£: {e}")
            if temp_path and os.path.exists(temp_path): os.remove(temp_path)
        return

    # (ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ù†Ø§) ØªÙ… Ø¬Ø¹Ù„ Ø´Ø±Ø· Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© Ø£ÙƒØ«Ø± Ù…Ø±ÙˆÙ†Ø©
    if any(keyword in text for keyword in KEYWORDS_CONFIRM) and user_id in user_pending_files:
        if user_id in user_wait_message:
            try: await user_wait_message.pop(user_id).delete()
            except Exception: pass
            
        pending_job = user_pending_files.pop(user_id)
        if not pending_job: return

        await event.reply("âœ… ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… ØªØ£ÙƒÙŠØ¯Ùƒ. Ø¬Ø§Ø±Ù Ø¥Ø±Ø³Ø§Ù„ Ø·Ù„Ø¨Ùƒ Ø¥Ù„Ù‰ Ø§Ù„Ù…ÙƒØªØ¨Ø©...")
        total_price = sum(item['price'] for item in pending_job.values())
        total_pages = sum(item['pages'] for item in pending_job.values())
        user_link = f"[{user_name}](tg://user?id={user_id})"
        
        summary_report = (f"**ğŸ“  Ø·Ù„Ø¨ Ø·Ø¨Ø§Ø¹Ø© Ø¬Ø¯ÙŠØ¯ Ù…Ø¤ÙƒØ¯**\n\n"
                          f"ğŸ‘¤ **Ø§Ù„Ø¹Ù…ÙŠÙ„:** {user_link}\n"
                          f"ğŸ“– **Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØµÙØ­Ø§Øª:** {total_pages}\n"
                          f"ğŸ’° **Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©:** {total_price} Ø¯.Ø¹\n\n"
                          f"**Ù„Ù„Ø·Ø¨Ø§Ø¹Ø©ØŒ Ù‚Ù… Ø¨Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø£ÙŠ Ù…Ù† Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„ØªØ§Ù„ÙŠØ© Ø¨Ø£Ù…Ø± `.Ø·Ø¨Ø§Ø¹Ø©`**")
        await send_group_notification(summary_report, parse_mode='md')
        
        for msg_id, item in pending_job.items():
            file_msg = item['msg']
            file_name = next((a.file_name for a in file_msg.document.attributes if hasattr(a, 'file_name')), "file.tmp")
            group_msg = await client.send_file(PRINTING_GROUP_ID, file_msg.media, caption=f"ğŸ“„ **Ù…Ù„Ù Ù„Ù„Ø·Ø¨Ø§Ø¹Ø©:** `{file_name}`", parse_mode='md')
            pending_group_prints[group_msg.id] = {'user_id': user_id, 'file_msg': file_msg}
            await asyncio.sleep(1)
        return

    if event.raw_text:
        if user_id in user_wait_message:
            try: await user_wait_message.pop(user_id).delete()
            except Exception: pass
        
        last_welcome = user_last_interaction_time.get(user_id)
        if not last_welcome or (datetime.now() - last_welcome > WELCOME_COOLDOWN):
            await event.reply(WELCOME_MESSAGE_TEXT.format(user_name=user_name), parse_mode='md')
            user_last_interaction_time[user_id] = datetime.now()
        else:
            user_wait_message[user_id] = await event.reply("â³ Ø´ÙƒØ±Ù‹Ø§ Ù„Ø±Ø³Ø§Ù„ØªÙƒ. Ø³ÙŠØªÙ… Ø§Ù„Ø±Ø¯ Ø¹Ù„ÙŠÙƒ Ø¨Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª Ù…Ù…ÙƒÙ†.")

# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø³Ø§Ø¯Ø³: Ø¯Ø§Ù„Ø© Ø§Ù„Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„ØªÙ†ÙÙŠØ°ÙŠØ© ---
# ----------------------------------------------------------------------------------
async def execute_print_job(status_msg, file_msg_to_print, user_id_to_notify, printer_name=None):
    file_name_original = next((a.file_name for a in file_msg_to_print.document.attributes if hasattr(a, 'file_name')), "file.tmp")
    local_file_path = None
    try:
        local_file_path = await find_or_download_file(status_msg, file_msg_to_print)
        
        printer_to_use = printer_name or PRINTER_NAME_1 or PRINTER_NAME_2
        if not printer_to_use: raise Exception("Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø£ÙŠ Ø·Ø§Ø¨Ø¹Ø©.")
        
        await status_msg.edit(f"ğŸ–¨ï¸ Ø¬Ø§Ø±Ù Ø¥Ø±Ø³Ø§Ù„ `{file_name_original}` Ø¥Ù„Ù‰ `{printer_to_use}`...")
        
        for i in range(0, 101, 20):
             await status_msg.edit(f"ğŸ–¨ï¸ Ø¬Ø§Ø±Ù Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©: `{file_name_original}`\n{create_progress_bar(i)}")
             await asyncio.sleep(1)

        success, message = await send_to_printer(local_file_path, printer_to_use)
        if not success: raise Exception(f"{message}")
        
        await status_msg.edit(f"âœ… ØªÙ…Øª Ø·Ø¨Ø§Ø¹Ø© `{file_name_original}` Ø¨Ù†Ø¬Ø§Ø­.")
        
        await client.send_message(user_id_to_notify, f"âœ… ØªÙ…Øª Ø·Ø¨Ø§Ø¹Ø© Ù…Ù„ÙÙƒ `{file_name_original}` Ø¨Ù†Ø¬Ø§Ø­.")
        await client.send_message(user_id_to_notify, ORDER_COMPLETION_MESSAGE_USER)
        
    except Exception as e:
        logger.error(f"Print execution error: {e}", exc_info=True)
        log_problem(f"Print execution error for user {user_id_to_notify}\n{traceback.format_exc()}")
        await status_msg.edit(f"âŒ Ø®Ø·Ø£ ÙØ§Ø¯Ø­ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø·Ø¨Ø§Ø¹Ø©: {e}")
    finally:
        if local_file_path and BOT_DOWNLOAD_PATH in local_file_path and os.path.exists(local_file_path):
            try: os.remove(local_file_path); logger.info(f"Cleaned up downloaded file: {local_file_path}")
            except Exception as e_clean: logger.error(f"Cleanup failed for {local_file_path}: {e_clean}")

# ----------------------------------------------------------------------------------
# --- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø³Ø§Ø¨Ø¹: Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ---
# ----------------------------------------------------------------------------------
async def main():
    global owner_id, bot_start_time
    if not all([API_ID, API_HASH, SESSION_STRING, PRINTING_GROUP_ID]):
        return logger.critical("âŒ Ø®Ø·Ø£ ÙØ§Ø¯Ø­: Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø§Ù‚ØµØ©.")

    os.makedirs(os.path.join(BOT_DOWNLOAD_PATH, "temp_saves"), exist_ok=True)
    os.makedirs(TELEGRAM_DESKTOP_PATH, exist_ok=True)
    logger.info(f"ğŸ“ Ù…Ø³Ø§Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„: {BOT_DOWNLOAD_PATH}")
    logger.info(f"ğŸ” Ù…Ø³Ø§Ø± Ø§Ù„Ø¨Ø­Ø«: {TELEGRAM_DESKTOP_PATH}")

    logger.info("â³ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª...")
    try:
        await client.start()
        me = await client.get_me()
        owner_id = me.id
        bot_start_time = datetime.now()
        logger.info(f"âœ… ØªÙ… Ø§Ù„ØªØ´ØºÙŠÙ„ ÙƒÙ€ '{me.first_name}' (ID: {owner_id}). Ø£Ù†Øª Ø§Ù„Ù…Ø§Ù„Ùƒ.")
        await send_group_notification(f"ğŸš€ **Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù†** | {me.first_name}")
        
        logger.info("ğŸ‘‚ Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø¢Ù† ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹...")
        await client.run_until_disconnected()
    except Exception as e:
        logger.critical(f"ğŸ’¥ Ø®Ø·Ø£ ÙØ§Ø¯Ø­ ÙÙŠ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©: {e}", exc_info=True)
        log_problem(f"CRITICAL ERROR IN MAIN FUNCTION\n{traceback.format_exc()}")
    finally:
        logger.info("--- Ø¨Ø¯Ø¡ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ´ØºÙŠÙ„ ---")
        if client.is_connected():
            await send_group_notification("â›” Ø§Ù„Ø¨ÙˆØª ÙŠØªÙˆÙ‚Ù Ø¹Ù† Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ø¢Ù†.")
            await client.disconnect()
        logger.info("âœ… Ø§ÙƒØªÙ…Ù„Øª Ø¹Ù…Ù„ÙŠØ© Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªØ´ØºÙŠÙ„.")

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main())
    except KeyboardInterrupt:
        logger.info("ğŸ›‘ ØªÙ… Ø·Ù„Ø¨ Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ctrl+C).")
    finally:
        tasks = [t for t in asyncio.all_tasks(loop=loop) if not t.done()]
        loop.run_until_complete(asyncio.gather(*tasks, return_exceptions=True))
        loop.close()
